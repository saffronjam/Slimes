#version 430

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

struct Agent{
	vec2 Position;
	float Angle;
};

layout(std140, binding = 3) buffer layoutName
{
    Agent agents[];
};

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float sense(Agent agent, float sensorAngleOffset)
{
	float width = 1024.0;
	float height = 512.0;
	int sensorSize = 3;

	float sensorAngle = agent.Angle + sensorAngleOffset;
	vec2 sensorDirection = vec2(cos(sensorAngle), sin(sensorAngle));
	ivec2 sensorCentre = ivec2(agent.Position) + ivec2(sensorDirection * vec2(10.0, 10.0));


	float sum = 0.0;
	for(int offsetX = -sensorSize; offsetX <= sensorSize; offsetX++)
	{
		for(int offsetY = -sensorSize; offsetY <= sensorSize; offsetY++)
		{
			ivec2 pos = sensorCentre + ivec2(offsetX, offsetY);

			if(pos.x >= 0 && pos.x < width && pos.y >= 0 && pos.y <= height)
			{
				sum += imageLoad(img_output, pos).x;
			}
		}
	}

	return sum;
}

void main() {

	float dt = 1.0 / 100.0;
	float moveSpeed = 250.0;
	float turnSpeed = 250.0f;

	float width = 1024.0;
	float height = 512.0;

	float sensorAngleSpacing = 3.1415 / 4.0;

	vec4 pixel = vec4(1.0, 1.0, 1.0, 1.0);

	Agent agent = agents[gl_GlobalInvocationID.x];

	float weightForward = sense(agent, 0);
	float weightLeft = sense(agent, sensorAngleSpacing);
	float weightRight = sense(agent, -sensorAngleSpacing);
	float randomSteerStrength = rand(vec2(1.0, 1.0));

	if( weightForward > weightLeft && weightForward > weightRight)
	{
		agent.Angle += 0;
	}
	else if( weightForward < weightLeft && weightForward < weightRight)
	{
		agent.Angle += (randomSteerStrength - 0.5) * 2.0 * turnSpeed * dt;
	}
	else if( weightRight > weightLeft )
	{
		agent.Angle -= randomSteerStrength * turnSpeed * dt;
	}
	else if( weightLeft > weightRight )
	{
		agent.Angle += randomSteerStrength * turnSpeed * dt;		
	}

	vec2 direction = vec2(cos(agent.Angle), sin(agent.Angle));
	vec2 newPosition = agent.Position + direction * moveSpeed * dt;

	if( newPosition.x < 0 || newPosition.x >= width || newPosition.y < 0 || newPosition.y >= height)
	{
		newPosition.x = min(width - 0.01, max(0.0, newPosition.x));
		newPosition.y = min(height - 0.01, max(0.0, newPosition.y));
		agent.Angle = 2.0 * 3.1415 * rand(vec2(agent.Angle, -agent.Angle));
	}

	agent.Position = newPosition;

	agents[gl_GlobalInvocationID.x] = agent;


	vec4 current = imageLoad(img_output, ivec2(agent.Position));

	float sum = current.x + current.y + current.z + 0.5;

	vec4 new = vec4(0.0);
	new.x = max(0.0, min(sum, 1.0));
	sum--;
	new.y = max(0.0, min(sum, 1.0));
	sum--;
	new.z = max(0.0, min(sum, 1.0));
	new.w = 1.0;

	// output to a specific pixel in the image
	imageStore(img_output, ivec2(agent.Position.x, agent.Position.y), new);
}
